<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SDOF Vibration Analysis Tool</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f0f4f8;
            color: #2d3748;
            min-height: 100vh;
        }
        .container {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        header {
            grid-column: 1 / -1;
            text-align: center;
            padding: 20px;
            background: linear-gradient(135deg, #4a90a4, #2c5f7c);
            border-radius: 10px;
            color: #fff;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        header h1 {
            font-size: 1.8rem;
            margin-bottom: 5px;
            color: #fff;
        }
        header p {
            color: rgba(255,255,255,0.8);
            font-size: 0.9rem;
        }
        .panel {
            background: #ffffff;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border: 1px solid #e2e8f0;
        }
        .input-panel h2, .plot-panel h2 {
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: #2c5f7c;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 10px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
            color: #4a5568;
            font-weight: 500;
        }
        .form-group input, .form-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #cbd5e0;
            border-radius: 5px;
            background: #fff;
            color: #2d3748;
            font-size: 1rem;
        }
        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #4a90a4;
            box-shadow: 0 0 0 3px rgba(74,144,164,0.15);
        }
        .derived-values {
            background: #f7fafc;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            border: 1px solid #e2e8f0;
        }
        .derived-values h3 {
            font-size: 0.95rem;
            margin-bottom: 12px;
            color: #2c5f7c;
        }
        .derived-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.9rem;
        }
        .derived-item:last-child {
            border-bottom: none;
        }
        .derived-item .value {
            color: #2c5f7c;
            font-weight: 600;
        }
        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .tab {
            padding: 10px 15px;
            background: #e2e8f0;
            border: none;
            border-radius: 5px;
            color: #4a5568;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
            font-weight: 500;
        }
        .tab:hover {
            background: #cbd5e0;
        }
        .tab.active {
            background: #4a90a4;
            color: #fff;
        }
        .btn {
            width: 100%;
            padding: 12px;
            background: #4a90a4;
            color: #fff;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.2s;
        }
        .btn:hover {
            background: #3d7a8c;
        }
        .plot-container {
            height: 500px;
            background: #fff;
            border-radius: 8px;
        }
        .options-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .options-row .form-group {
            flex: 1;
            min-width: 100px;
            margin-bottom: 0;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
        }
        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #4a90a4;
        }
        .checkbox-group label {
            color: #4a5568;
        }
        .srs-info {
            background: #edf2f7;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 0.85rem;
            color: #4a5568;
            border-left: 3px solid #4a90a4;
        }
        .srs-info strong {
            color: #2c5f7c;
        }
        @media (max-width: 900px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>SDOF Vibration Analysis Tool</h1>
            <p>Single Degree of Freedom System Analysis with Shock Response Spectrum</p>
        </header>

        <div class="panel input-panel">
            <h2>System Parameters</h2>

            <div class="form-group">
                <label>Mass (kg)</label>
                <input type="number" id="mass" value="10" step="0.1" min="0.001">
            </div>

            <div class="form-group">
                <label>Stiffness (N/m)</label>
                <input type="number" id="stiffness" value="1000" step="1" min="0.001">
            </div>

            <div class="form-group">
                <label>Damping Type</label>
                <select id="dampingType">
                    <option value="coefficient">Coefficient (N·s/m)</option>
                    <option value="ratio">Damping Ratio (ζ)</option>
                </select>
            </div>

            <div class="form-group">
                <label id="dampingLabel">Damping (N·s/m)</label>
                <input type="number" id="damping" value="20" step="0.1" min="0">
            </div>

            <div class="derived-values">
                <h3>Derived Properties</h3>
                <div class="derived-item">
                    <span>ωn (rad/s)</span>
                    <span class="value" id="omega_n">—</span>
                </div>
                <div class="derived-item">
                    <span>fn (Hz)</span>
                    <span class="value" id="f_n">—</span>
                </div>
                <div class="derived-item">
                    <span>ζ (damping ratio)</span>
                    <span class="value" id="zeta">—</span>
                </div>
                <div class="derived-item">
                    <span>ωd (rad/s)</span>
                    <span class="value" id="omega_d">—</span>
                </div>
                <div class="derived-item">
                    <span>Damping Type</span>
                    <span class="value" id="dampingTypeDisplay">—</span>
                </div>
            </div>

            <button class="btn" onclick="calculate()">Calculate</button>
        </div>

        <div class="panel plot-panel">
            <div class="tabs">
                <button class="tab active" onclick="switchTab('frf')">Frequency Response</button>
                <button class="tab" onclick="switchTab('trans')">Transmissibility</button>
                <button class="tab" onclick="switchTab('time')">Time Response</button>
                <button class="tab" onclick="switchTab('srs')">Shock Response Spectrum</button>
            </div>

            <div id="frf-options" class="options-row">
                <div class="form-group">
                    <label>Freq min (Hz)</label>
                    <input type="number" id="freqMin" value="0.1" step="0.1" min="0.01">
                </div>
                <div class="form-group">
                    <label>Freq max (Hz)</label>
                    <input type="number" id="freqMax" value="100" step="1" min="1">
                </div>
            </div>

            <div id="trans-options" class="options-row" style="display:none;">
                <div class="form-group">
                    <label>Freq min (Hz)</label>
                    <input type="number" id="transFreqMin" value="0.1" step="0.1" min="0.01">
                </div>
                <div class="form-group">
                    <label>Freq max (Hz)</label>
                    <input type="number" id="transFreqMax" value="100" step="1" min="1">
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="multiZeta">
                    <label for="multiZeta">Show multiple ζ curves</label>
                </div>
            </div>

            <div id="time-options" style="display:none;">
                <div class="options-row">
                    <div class="form-group">
                        <label>Response Type</label>
                        <select id="timeResponseType" onchange="updateTimeOptionsVisibility(); calculate();">
                            <option value="impulse">Impulse</option>
                            <option value="step">Step</option>
                            <option value="harmonic">Harmonic</option>
                            <option value="ramp">Ramp Force</option>
                            <option value="chirp">Swept Sine (Chirp)</option>
                            <option value="halfsine">Half-Sine Pulse</option>
                            <option value="free">Free Vibration</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Duration (s)</label>
                        <input type="number" id="duration" value="5" step="0.5" min="0.1">
                    </div>
                    <div class="form-group" id="amplitudeGroup">
                        <label id="amplitudeLabel">Impulse (N·s)</label>
                        <input type="number" id="excitationAmplitude" value="1" step="0.1" min="0.001">
                    </div>
                    <div class="form-group" id="excitationFreqGroup">
                        <label>Excitation Frequency (Hz)</label>
                        <input type="number" id="excitationFreq" value="1.5" step="0.1" min="0.01">
                    </div>
                </div>
                <div class="options-row">
                    <div class="form-group">
                        <label>Max Allowable Displacement (m)</label>
                        <input type="number" id="maxDisplacement" value="0.1" step="0.01" min="0.001">
                    </div>
                    <div class="checkbox-group" style="margin-top: 0; align-self: flex-end; padding-bottom: 10px;">
                        <input type="checkbox" id="showMaxDisp" checked>
                        <label for="showMaxDisp">Show limit</label>
                    </div>
                </div>
                <div class="options-row" id="harmonicInfoRow" style="display:none;">
                    <div class="form-group">
                        <label>Frequency Ratio (ω/ωn)</label>
                        <input type="text" id="freqRatioDisplay" value="—" readonly style="background:#f7fafc; border-color:#cbd5e0;">
                    </div>
                    <div class="form-group">
                        <label>At Resonance?</label>
                        <input type="text" id="resonanceDisplay" value="—" readonly style="background:#f7fafc; border-color:#cbd5e0;">
                    </div>
                </div>
                <div class="options-row" id="freeVibOptions" style="display:none;">
                    <div class="form-group">
                        <label>Initial Displacement (m)</label>
                        <input type="number" id="initialDisp" value="1" step="0.1">
                    </div>
                    <div class="form-group">
                        <label>Initial Velocity (m/s)</label>
                        <input type="number" id="initialVel" value="0" step="0.1">
                    </div>
                </div>
                <div class="options-row" id="rampOptions" style="display:none;">
                    <div class="form-group">
                        <label>Ramp Time (s)</label>
                        <input type="number" id="rampTime" value="0.5" step="0.1" min="0.01">
                    </div>
                </div>
                <div class="options-row" id="chirpOptions" style="display:none;">
                    <div class="form-group">
                        <label>Start Frequency (Hz)</label>
                        <input type="number" id="chirpStartFreq" value="0.1" step="0.1" min="0.01">
                    </div>
                    <div class="form-group">
                        <label>End Frequency (Hz)</label>
                        <input type="number" id="chirpEndFreq" value="5" step="0.1" min="0.1">
                    </div>
                </div>
                <div class="options-row" id="halfsineOptions" style="display:none;">
                    <div class="form-group">
                        <label>Pulse Duration (ms)</label>
                        <input type="number" id="halfsinePulseDuration" value="50" step="1" min="1">
                    </div>
                </div>
            </div>

            <div id="srs-options" style="display:none;">
                <div class="srs-info">
                    <strong>Shock Response Spectrum (SRS)</strong> shows the peak response of SDOF oscillators
                    with varying natural frequencies when subjected to a transient shock input.
                </div>
                <div class="options-row">
                    <div class="form-group">
                        <label>Shock Pulse Type</label>
                        <select id="pulseType">
                            <option value="half_sine">Half Sine</option>
                            <option value="versed_sine">Versed Sine (Haversine)</option>
                            <option value="triangular">Triangular (Isosceles)</option>
                            <option value="rectangular">Rectangular</option>
                            <option value="trapezoidal">Trapezoidal</option>
                            <option value="initial_peak_sawtooth">Initial Peak Sawtooth</option>
                            <option value="terminal_peak_sawtooth">Terminal Peak Sawtooth</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Pulse Duration (ms)</label>
                        <input type="number" id="pulseDuration" value="11" step="1" min="1">
                    </div>
                    <div class="form-group">
                        <label>Peak Amplitude (g)</label>
                        <input type="number" id="pulseAmplitude" value="50" step="1" min="1">
                    </div>
                </div>
                <div class="options-row">
                    <div class="form-group">
                        <label>SRS Freq min (Hz)</label>
                        <input type="number" id="srsFreqMin" value="10" step="1" min="1">
                    </div>
                    <div class="form-group">
                        <label>SRS Freq max (Hz)</label>
                        <input type="number" id="srsFreqMax" value="2000" step="10" min="10">
                    </div>
                    <div class="form-group">
                        <label>SRS Damping (Q)</label>
                        <input type="number" id="srsDamping" value="10" step="1" min="2">
                    </div>
                </div>
                <div class="options-row">
                    <div class="form-group">
                        <label>SRS Type</label>
                        <select id="srsType">
                            <option value="maxi_max">Maxi-Max (Absolute Maximum)</option>
                            <option value="primary">Primary (During Shock)</option>
                            <option value="residual">Residual (After Shock)</option>
                            <option value="all">All Components</option>
                        </select>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showPulse" checked>
                        <label for="showPulse">Show input pulse</label>
                    </div>
                </div>
            </div>

            <div id="plot" class="plot-container"></div>
        </div>
    </div>

    <script>
        let currentTab = 'frf';

        // SDOF System calculations
        class SDOFSystem {
            constructor(mass, stiffness, damping) {
                this.mass = mass;
                this.stiffness = stiffness;
                this.damping = damping;
            }

            static fromDampingRatio(mass, stiffness, zeta) {
                const cCritical = 2 * Math.sqrt(stiffness * mass);
                return new SDOFSystem(mass, stiffness, zeta * cCritical);
            }

            get naturalFrequency() {
                return Math.sqrt(this.stiffness / this.mass);
            }

            get naturalFrequencyHz() {
                return this.naturalFrequency / (2 * Math.PI);
            }

            get criticalDamping() {
                return 2 * Math.sqrt(this.stiffness * this.mass);
            }

            get dampingRatio() {
                return this.damping / this.criticalDamping;
            }

            get dampedFrequency() {
                const zeta = this.dampingRatio;
                if (zeta >= 1.0) return 0;
                return this.naturalFrequency * Math.sqrt(1 - zeta * zeta);
            }

            get isUnderdamped() {
                return this.dampingRatio < 1.0;
            }
        }

        // Compute FRF
        function computeFRF(system, frequencies) {
            const magnitudeDb = [];
            const phaseDeg = [];

            for (const f of frequencies) {
                const omega = 2 * Math.PI * f;
                const m = system.mass;
                const k = system.stiffness;
                const c = system.damping;

                const real = k - m * omega * omega;
                const imag = c * omega;
                const denomMag = Math.sqrt(real * real + imag * imag);

                const H_mag = 1 / denomMag;
                magnitudeDb.push(20 * Math.log10(H_mag * k));
                phaseDeg.push(-Math.atan2(imag, real) * 180 / Math.PI);
            }

            return { magnitudeDb, phaseDeg };
        }

        // Compute Transmissibility
        function computeTransmissibility(zeta, frequencyRatios) {
            return frequencyRatios.map(r => {
                const num = 1 + Math.pow(2 * zeta * r, 2);
                const den = Math.pow(1 - r * r, 2) + Math.pow(2 * zeta * r, 2);
                return Math.sqrt(num / den);
            });
        }

        // Compute impulse response
        function computeImpulseResponse(system, time, impulse = 1) {
            const m = system.mass;
            const wn = system.naturalFrequency;
            const zeta = system.dampingRatio;

            return time.map(t => {
                if (t < 0) return 0;
                if (zeta < 1) {
                    // Underdamped
                    const wd = wn * Math.sqrt(1 - zeta * zeta);
                    return impulse * (1 / (m * wd)) * Math.exp(-zeta * wn * t) * Math.sin(wd * t);
                } else if (Math.abs(zeta - 1) < 0.001) {
                    // Critically damped
                    return impulse * (1 / m) * t * Math.exp(-wn * t);
                } else {
                    // Overdamped
                    const wd = wn * Math.sqrt(zeta * zeta - 1);
                    return impulse * (1 / (m * 2 * wd)) * (Math.exp((-zeta * wn + wd) * t) - Math.exp((-zeta * wn - wd) * t));
                }
            });
        }

        // Compute step response
        function computeStepResponse(system, time, forceAmplitude = 1) {
            const k = system.stiffness;
            const wn = system.naturalFrequency;
            const zeta = system.dampingRatio;
            const xStatic = forceAmplitude / k;

            return time.map(t => {
                if (t < 0) return 0;
                if (zeta < 1) {
                    // Underdamped
                    const wd = wn * Math.sqrt(1 - zeta * zeta);
                    const sqrtTerm = Math.sqrt(1 - zeta * zeta);
                    return xStatic * (1 - Math.exp(-zeta * wn * t) *
                        (Math.cos(wd * t) + (zeta / sqrtTerm) * Math.sin(wd * t)));
                } else if (Math.abs(zeta - 1) < 0.001) {
                    // Critically damped
                    return xStatic * (1 - (1 + wn * t) * Math.exp(-wn * t));
                } else {
                    // Overdamped
                    const sqrtTerm = Math.sqrt(zeta * zeta - 1);
                    const s1 = wn * (-zeta + sqrtTerm);
                    const s2 = wn * (-zeta - sqrtTerm);
                    return xStatic * (1 + (s2 * Math.exp(s1 * t) - s1 * Math.exp(s2 * t)) / (s1 - s2));
                }
            });
        }

        // Compute harmonic response
        function computeHarmonicResponse(system, time, excitationFreq, forceAmplitude = 1) {
            const m = system.mass;
            const k = system.stiffness;
            const c = system.damping;
            const omega = 2 * Math.PI * excitationFreq;
            const wn = system.naturalFrequency;
            const zeta = system.dampingRatio;

            // Steady-state amplitude and phase (includes damping)
            const denom = Math.sqrt(Math.pow(k - m * omega * omega, 2) + Math.pow(c * omega, 2));
            const X = forceAmplitude / denom;
            const phi = Math.atan2(c * omega, k - m * omega * omega);

            // Initial conditions for transient (to satisfy zero IC)
            const x0_trans = -X * Math.sin(-phi);
            const v0_trans = -X * omega * Math.cos(-phi);

            return time.map(t => {
                if (t < 0) return 0;
                // Steady-state response
                const xSteady = X * Math.sin(omega * t - phi);

                // Transient response to satisfy zero initial conditions
                let xTransient = 0;
                if (zeta < 1) {
                    // Underdamped transient
                    const wd = wn * Math.sqrt(1 - zeta * zeta);
                    const A = x0_trans;
                    const B = (v0_trans + zeta * wn * x0_trans) / wd;
                    xTransient = Math.exp(-zeta * wn * t) * (A * Math.cos(wd * t) + B * Math.sin(wd * t));
                } else if (Math.abs(zeta - 1) < 0.001) {
                    // Critically damped transient
                    const A = x0_trans;
                    const B = v0_trans + wn * x0_trans;
                    xTransient = (A + B * t) * Math.exp(-wn * t);
                } else {
                    // Overdamped transient
                    const sqrtTerm = Math.sqrt(zeta * zeta - 1);
                    const s1 = wn * (-zeta + sqrtTerm);
                    const s2 = wn * (-zeta - sqrtTerm);
                    const A = (x0_trans * s2 - v0_trans) / (s2 - s1);
                    const B = (v0_trans - x0_trans * s1) / (s2 - s1);
                    xTransient = A * Math.exp(s1 * t) + B * Math.exp(s2 * t);
                }

                return xSteady + xTransient;
            });
        }

        // Compute free vibration
        function computeFreeVibration(system, time, x0 = 1, v0 = 0) {
            const wn = system.naturalFrequency;
            const zeta = system.dampingRatio;

            return time.map(t => {
                if (t < 0) return 0;
                if (zeta < 1) {
                    // Underdamped
                    const wd = wn * Math.sqrt(1 - zeta * zeta);
                    const A = x0;
                    const B = (v0 + zeta * wn * x0) / wd;
                    return Math.exp(-zeta * wn * t) * (A * Math.cos(wd * t) + B * Math.sin(wd * t));
                } else if (Math.abs(zeta - 1) < 0.001) {
                    // Critically damped
                    const A = x0;
                    const B = v0 + wn * x0;
                    return (A + B * t) * Math.exp(-wn * t);
                } else {
                    // Overdamped
                    const sqrtTerm = Math.sqrt(zeta * zeta - 1);
                    const s1 = wn * (-zeta + sqrtTerm);
                    const s2 = wn * (-zeta - sqrtTerm);
                    const A = (x0 * s2 - v0) / (s2 - s1);
                    const B = (v0 - x0 * s1) / (s2 - s1);
                    return A * Math.exp(s1 * t) + B * Math.exp(s2 * t);
                }
            });
        }

        // Compute ramp force response using Newmark-beta integration
        function computeRampResponse(system, time, rampTime, forceAmplitude = 1) {
            const m = system.mass;
            const k = system.stiffness;
            const c = system.damping;
            const dt = time[1] - time[0];
            const n = time.length;

            // Newmark-beta parameters (average acceleration)
            const gamma = 0.5;
            const beta = 0.25;

            const x = new Array(n).fill(0);
            const v = new Array(n).fill(0);
            const a = new Array(n).fill(0);

            // Force function: ramp up to forceAmplitude over rampTime, then constant
            const force = time.map(t => {
                if (t < rampTime) return forceAmplitude * (t / rampTime);
                return forceAmplitude;
            });

            // Initial acceleration
            a[0] = force[0] / m;

            // Effective stiffness
            const kEff = k + gamma / (beta * dt) * c + 1 / (beta * dt * dt) * m;

            for (let i = 0; i < n - 1; i++) {
                const pEff = force[i + 1] +
                    m * (1 / (beta * dt * dt) * x[i] + 1 / (beta * dt) * v[i] + (1 / (2 * beta) - 1) * a[i]) +
                    c * (gamma / (beta * dt) * x[i] + (gamma / beta - 1) * v[i] + dt * (gamma / (2 * beta) - 1) * a[i]);

                x[i + 1] = pEff / kEff;
                v[i + 1] = gamma / (beta * dt) * (x[i + 1] - x[i]) + (1 - gamma / beta) * v[i] + dt * (1 - gamma / (2 * beta)) * a[i];
                a[i + 1] = 1 / (beta * dt * dt) * (x[i + 1] - x[i]) - 1 / (beta * dt) * v[i] - (1 / (2 * beta) - 1) * a[i];
            }

            return { displacement: x, force: force };
        }

        // Compute swept sine (chirp) response using Newmark-beta integration
        function computeChirpResponse(system, time, startFreq, endFreq, forceAmplitude = 1) {
            const m = system.mass;
            const k = system.stiffness;
            const c = system.damping;
            const dt = time[1] - time[0];
            const n = time.length;
            const duration = time[n - 1];

            // Newmark-beta parameters
            const gamma = 0.5;
            const beta = 0.25;

            const x = new Array(n).fill(0);
            const v = new Array(n).fill(0);
            const a = new Array(n).fill(0);

            // Linear chirp: frequency increases linearly from startFreq to endFreq
            const freqRate = (endFreq - startFreq) / duration;
            const force = time.map(t => {
                const instantFreq = startFreq + freqRate * t;
                const phase = 2 * Math.PI * (startFreq * t + 0.5 * freqRate * t * t);
                return forceAmplitude * Math.sin(phase);
            });

            a[0] = force[0] / m;

            const kEff = k + gamma / (beta * dt) * c + 1 / (beta * dt * dt) * m;

            for (let i = 0; i < n - 1; i++) {
                const pEff = force[i + 1] +
                    m * (1 / (beta * dt * dt) * x[i] + 1 / (beta * dt) * v[i] + (1 / (2 * beta) - 1) * a[i]) +
                    c * (gamma / (beta * dt) * x[i] + (gamma / beta - 1) * v[i] + dt * (gamma / (2 * beta) - 1) * a[i]);

                x[i + 1] = pEff / kEff;
                v[i + 1] = gamma / (beta * dt) * (x[i + 1] - x[i]) + (1 - gamma / beta) * v[i] + dt * (1 - gamma / (2 * beta)) * a[i];
                a[i + 1] = 1 / (beta * dt * dt) * (x[i + 1] - x[i]) - 1 / (beta * dt) * v[i] - (1 / (2 * beta) - 1) * a[i];
            }

            return { displacement: x, force: force };
        }

        // Compute half-sine pulse response using Newmark-beta integration
        function computeHalfSineResponse(system, time, pulseDuration, forceAmplitude = 1) {
            const m = system.mass;
            const k = system.stiffness;
            const c = system.damping;
            const dt = time[1] - time[0];
            const n = time.length;

            // Newmark-beta parameters
            const gamma = 0.5;
            const beta = 0.25;

            const x = new Array(n).fill(0);
            const v = new Array(n).fill(0);
            const a = new Array(n).fill(0);

            // Half-sine pulse: F(t) = F0 * sin(π*t/T) for 0 <= t <= T, then 0
            const force = time.map(t => {
                if (t <= pulseDuration) {
                    return forceAmplitude * Math.sin(Math.PI * t / pulseDuration);
                }
                return 0;
            });

            a[0] = force[0] / m;

            const kEff = k + gamma / (beta * dt) * c + 1 / (beta * dt * dt) * m;

            for (let i = 0; i < n - 1; i++) {
                const pEff = force[i + 1] +
                    m * (1 / (beta * dt * dt) * x[i] + 1 / (beta * dt) * v[i] + (1 / (2 * beta) - 1) * a[i]) +
                    c * (gamma / (beta * dt) * x[i] + (gamma / beta - 1) * v[i] + dt * (gamma / (2 * beta) - 1) * a[i]);

                x[i + 1] = pEff / kEff;
                v[i + 1] = gamma / (beta * dt) * (x[i + 1] - x[i]) + (1 - gamma / beta) * v[i] + dt * (1 - gamma / (2 * beta)) * a[i];
                a[i + 1] = 1 / (beta * dt * dt) * (x[i + 1] - x[i]) - 1 / (beta * dt) * v[i] - (1 / (2 * beta) - 1) * a[i];
            }

            return { displacement: x, force: force };
        }

        // Generate shock pulse
        function generateShockPulse(pulseType, duration, amplitude, dt) {
            const totalTime = duration * 10;
            const n = Math.ceil(totalTime / dt);
            const t = [];
            const accel = [];

            for (let i = 0; i < n; i++) {
                t.push(i * dt);
                accel.push(0);
            }

            const pulseSamples = Math.ceil(duration / dt);

            for (let i = 0; i < pulseSamples && i < n; i++) {
                const tPulse = i * dt;

                switch (pulseType) {
                    case 'half_sine':
                        accel[i] = amplitude * Math.sin(Math.PI * tPulse / duration);
                        break;
                    case 'versed_sine':
                        accel[i] = amplitude * (1 - Math.cos(2 * Math.PI * tPulse / duration)) / 2;
                        break;
                    case 'triangular':
                        if (tPulse < duration / 2) {
                            accel[i] = amplitude * 2 * tPulse / duration;
                        } else {
                            accel[i] = amplitude * (2 - 2 * tPulse / duration);
                        }
                        break;
                    case 'rectangular':
                        accel[i] = amplitude;
                        break;
                    case 'trapezoidal':
                        const riseTime = duration / 4;
                        const holdEnd = 3 * duration / 4;
                        if (tPulse < riseTime) {
                            accel[i] = amplitude * tPulse / riseTime;
                        } else if (tPulse < holdEnd) {
                            accel[i] = amplitude;
                        } else {
                            accel[i] = amplitude * (1 - (tPulse - holdEnd) / riseTime);
                        }
                        break;
                    case 'initial_peak_sawtooth':
                        accel[i] = amplitude * (1 - tPulse / duration);
                        break;
                    case 'terminal_peak_sawtooth':
                        accel[i] = amplitude * tPulse / duration;
                        break;
                }
            }

            return { t, accel };
        }

        // Compute SDOF response using Newmark-beta
        function computeSDOFResponse(naturalFreq, dampingRatio, baseAccel, dt) {
            const omega_n = 2 * Math.PI * naturalFreq;
            const n = baseAccel.length;

            const x = new Array(n).fill(0);
            const v = new Array(n).fill(0);
            const a = new Array(n).fill(0);

            a[0] = -baseAccel[0];

            const gamma = 0.5;
            const beta = 0.25;

            const k_eff = omega_n * omega_n + gamma / (beta * dt) * 2 * dampingRatio * omega_n + 1 / (beta * dt * dt);

            for (let i = 0; i < n - 1; i++) {
                const p_eff = (-baseAccel[i + 1] +
                    (1 / (beta * dt * dt)) * x[i] +
                    (1 / (beta * dt)) * v[i] +
                    (1 / (2 * beta) - 1) * a[i] +
                    2 * dampingRatio * omega_n * (
                        (gamma / (beta * dt)) * x[i] +
                        (gamma / beta - 1) * v[i] +
                        dt * (gamma / (2 * beta) - 1) * a[i]
                    ));

                x[i + 1] = p_eff / k_eff;
                v[i + 1] = (gamma / (beta * dt)) * (x[i + 1] - x[i]) + (1 - gamma / beta) * v[i] + dt * (1 - gamma / (2 * beta)) * a[i];
                a[i + 1] = (1 / (beta * dt * dt)) * (x[i + 1] - x[i]) - (1 / (beta * dt)) * v[i] - (1 / (2 * beta) - 1) * a[i];
            }

            return x;
        }

        // Compute SRS
        function computeSRS(baseAccel, dt, frequencies, dampingRatio) {
            const n_freq = frequencies.length;

            // Find shock end
            const peakAccel = Math.max(...baseAccel.map(Math.abs));
            let shockEndIdx = baseAccel.length - 1;
            for (let i = baseAccel.length - 1; i >= 0; i--) {
                if (Math.abs(baseAccel[i]) > 0.01 * peakAccel) {
                    shockEndIdx = i;
                    break;
                }
            }

            const results = {
                maxi_max: [],
                primary_pos: [],
                primary_neg: [],
                residual_pos: [],
                residual_neg: []
            };

            for (let i = 0; i < n_freq; i++) {
                const fn = frequencies[i];
                const x = computeSDOFResponse(fn, dampingRatio, baseAccel, dt);

                // Convert to pseudo-acceleration
                const omega_n = 2 * Math.PI * fn;
                const response = x.map(xi => omega_n * omega_n * xi);

                // Primary
                const primary = response.slice(0, shockEndIdx + 1);
                results.primary_pos.push(Math.max(...primary));
                results.primary_neg.push(Math.abs(Math.min(...primary)));

                // Residual
                const residual = response.slice(shockEndIdx + 1);
                if (residual.length > 0) {
                    results.residual_pos.push(Math.max(...residual));
                    results.residual_neg.push(Math.abs(Math.min(...residual)));
                } else {
                    results.residual_pos.push(0);
                    results.residual_neg.push(0);
                }

                // Maxi-max
                results.maxi_max.push(Math.max(...response.map(Math.abs)));
            }

            return results;
        }

        // Generate arrays
        function linspace(start, end, n) {
            const arr = [];
            const step = (end - start) / (n - 1);
            for (let i = 0; i < n; i++) {
                arr.push(start + step * i);
            }
            return arr;
        }

        function logspace(start, end, n) {
            const logStart = Math.log10(start);
            const logEnd = Math.log10(end);
            return linspace(logStart, logEnd, n).map(x => Math.pow(10, x));
        }

        // UI Functions
        function getSystem() {
            const mass = parseFloat(document.getElementById('mass').value);
            const stiffness = parseFloat(document.getElementById('stiffness').value);
            const dampingValue = parseFloat(document.getElementById('damping').value);
            const dampingType = document.getElementById('dampingType').value;

            if (dampingType === 'ratio') {
                return SDOFSystem.fromDampingRatio(mass, stiffness, dampingValue);
            }
            return new SDOFSystem(mass, stiffness, dampingValue);
        }

        function updateDerivedValues() {
            try {
                const system = getSystem();
                document.getElementById('omega_n').textContent = system.naturalFrequency.toFixed(4);
                document.getElementById('f_n').textContent = system.naturalFrequencyHz.toFixed(4);
                document.getElementById('zeta').textContent = system.dampingRatio.toFixed(4);
                document.getElementById('omega_d').textContent = system.dampedFrequency.toFixed(4);

                if (system.dampingRatio < 1) {
                    document.getElementById('dampingTypeDisplay').textContent = 'Underdamped';
                } else if (Math.abs(system.dampingRatio - 1) < 0.001) {
                    document.getElementById('dampingTypeDisplay').textContent = 'Critically Damped';
                } else {
                    document.getElementById('dampingTypeDisplay').textContent = 'Overdamped';
                }
            } catch (e) {
                console.error(e);
            }
        }

        function switchTab(tab) {
            currentTab = tab;
            document.querySelectorAll('.tab').forEach((t, i) => {
                t.classList.remove('active');
                if ((tab === 'frf' && i === 0) || (tab === 'trans' && i === 1) ||
                    (tab === 'time' && i === 2) || (tab === 'srs' && i === 3)) {
                    t.classList.add('active');
                }
            });

            document.getElementById('frf-options').style.display = tab === 'frf' ? 'flex' : 'none';
            document.getElementById('trans-options').style.display = tab === 'trans' ? 'flex' : 'none';
            document.getElementById('time-options').style.display = tab === 'time' ? 'block' : 'none';
            document.getElementById('srs-options').style.display = tab === 'srs' ? 'block' : 'none';

            if (tab === 'time') {
                updateTimeOptionsVisibility();
            }

            calculate();
        }

        function updateTimeOptionsVisibility() {
            const responseType = document.getElementById('timeResponseType').value;
            const harmonicInfoRow = document.getElementById('harmonicInfoRow');
            const freeVibOptions = document.getElementById('freeVibOptions');
            const rampOptions = document.getElementById('rampOptions');
            const chirpOptions = document.getElementById('chirpOptions');
            const amplitudeGroup = document.getElementById('amplitudeGroup');
            const amplitudeLabel = document.getElementById('amplitudeLabel');
            const excitationFreqGroup = document.getElementById('excitationFreqGroup');

            // Show/hide harmonic-specific info row (frequency ratio, resonance)
            harmonicInfoRow.style.display = (responseType === 'harmonic') ? 'flex' : 'none';

            // Show/hide excitation frequency (only for harmonic)
            excitationFreqGroup.style.display = (responseType === 'harmonic') ? 'block' : 'none';

            // Show/hide free vibration options
            freeVibOptions.style.display = (responseType === 'free') ? 'flex' : 'none';

            // Show/hide ramp options
            rampOptions.style.display = (responseType === 'ramp') ? 'flex' : 'none';

            // Show/hide chirp options
            chirpOptions.style.display = (responseType === 'chirp') ? 'flex' : 'none';

            // Show/hide half-sine options
            const halfsineOptions = document.getElementById('halfsineOptions');
            halfsineOptions.style.display = (responseType === 'halfsine') ? 'flex' : 'none';

            // Update amplitude label and visibility
            if (responseType === 'free') {
                amplitudeGroup.style.display = 'none';
            } else {
                amplitudeGroup.style.display = 'block';
                switch (responseType) {
                    case 'impulse':
                        amplitudeLabel.textContent = 'Impulse (N·s)';
                        break;
                    case 'step':
                        amplitudeLabel.textContent = 'Force Amplitude (N)';
                        break;
                    case 'harmonic':
                        amplitudeLabel.textContent = 'Force Amplitude (N)';
                        break;
                    case 'ramp':
                        amplitudeLabel.textContent = 'Final Force (N)';
                        break;
                    case 'chirp':
                        amplitudeLabel.textContent = 'Force Amplitude (N)';
                        break;
                    case 'halfsine':
                        amplitudeLabel.textContent = 'Max Shock (g)';
                        document.getElementById('excitationAmplitude').value = '50';
                        break;
                }
            }

            // Update frequency ratio display if harmonic
            if (responseType === 'harmonic') {
                try {
                    const system = getSystem();
                    const excitationFreq = parseFloat(document.getElementById('excitationFreq').value);
                    const freqRatio = excitationFreq / system.naturalFrequencyHz;
                    document.getElementById('freqRatioDisplay').value = freqRatio.toFixed(3);

                    // Check if near resonance (within 10%)
                    const resonanceDisplay = document.getElementById('resonanceDisplay');
                    if (Math.abs(freqRatio - 1) < 0.1) {
                        resonanceDisplay.value = 'YES - Near resonance!';
                        resonanceDisplay.style.color = '#ff6b6b';
                    } else if (freqRatio < 1) {
                        resonanceDisplay.value = 'Below resonance';
                        resonanceDisplay.style.color = '#888';
                    } else {
                        resonanceDisplay.value = 'Above resonance';
                        resonanceDisplay.style.color = '#888';
                    }
                } catch (e) {}
            }
        }

        function calculate() {
            const system = getSystem();
            updateDerivedValues();

            const plotDiv = document.getElementById('plot');
            const layout = {
                paper_bgcolor: '#ffffff',
                plot_bgcolor: '#f8fafc',
                font: { color: '#2d3748' },
                xaxis: { gridcolor: '#e2e8f0', zerolinecolor: '#cbd5e0', autorange: true },
                yaxis: { gridcolor: '#e2e8f0', zerolinecolor: '#cbd5e0', autorange: true },
                margin: { t: 60, r: 20, b: 50, l: 60 }
            };
            const config = {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['lasso2d', 'select2d'],
                displaylogo: false
            };

            if (currentTab === 'frf') {
                const fMin = parseFloat(document.getElementById('freqMin').value);
                const fMax = parseFloat(document.getElementById('freqMax').value);
                const frequencies = logspace(fMin, fMax, 500);
                const { magnitudeDb, phaseDeg } = computeFRF(system, frequencies);

                const traces = [
                    {
                        x: frequencies,
                        y: magnitudeDb,
                        type: 'scatter',
                        name: 'Magnitude',
                        line: { color: '#2c5f7c', width: 2 },
                        xaxis: 'x',
                        yaxis: 'y'
                    },
                    {
                        x: frequencies,
                        y: phaseDeg,
                        type: 'scatter',
                        name: 'Phase',
                        line: { color: '#ff6b6b' },
                        xaxis: 'x2',
                        yaxis: 'y2'
                    }
                ];

                const frfLayout = {
                    ...layout,
                    title: 'Frequency Response Function',
                    grid: { rows: 2, columns: 1, pattern: 'independent' },
                    xaxis: { ...layout.xaxis, type: 'log', title: 'Frequency (Hz)', autorange: true },
                    yaxis: { ...layout.yaxis, title: 'Magnitude (dB)', domain: [0.55, 1], autorange: true },
                    xaxis2: { ...layout.xaxis, type: 'log', title: 'Frequency (Hz)', autorange: true },
                    yaxis2: { ...layout.yaxis, title: 'Phase (deg)', domain: [0, 0.4], autorange: true },
                    showlegend: false,
                    shapes: [
                        { type: 'line', x0: system.naturalFrequencyHz, x1: system.naturalFrequencyHz, y0: 0, y1: 1, yref: 'paper', line: { color: 'red', dash: 'dash' } }
                    ],
                    annotations: [
                        { x: Math.log10(system.naturalFrequencyHz), y: 1, yref: 'paper', text: `fn = ${system.naturalFrequencyHz.toFixed(2)} Hz`, showarrow: false, yanchor: 'bottom', font: { color: 'red' } }
                    ]
                };

                Plotly.newPlot(plotDiv, traces, frfLayout, config);

            } else if (currentTab === 'trans') {
                const fMin = parseFloat(document.getElementById('transFreqMin').value);
                const fMax = parseFloat(document.getElementById('transFreqMax').value);
                const frequencies = linspace(fMin, fMax, 500);
                const r = frequencies.map(f => f / system.naturalFrequencyHz);
                const multiZeta = document.getElementById('multiZeta').checked;

                const traces = [];
                if (multiZeta) {
                    const zetaValues = [0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 1.0];
                    const colors = ['#2c5f7c', '#2d882d', '#e6a817', '#d35400', '#c0392b', '#8e44ad', '#34495e'];
                    zetaValues.forEach((z, i) => {
                        traces.push({
                            x: frequencies,
                            y: computeTransmissibility(z, r),
                            type: 'scatter',
                            name: `ζ = ${z}`,
                            line: { color: colors[i] }
                        });
                    });
                } else {
                    traces.push({
                        x: frequencies,
                        y: computeTransmissibility(system.dampingRatio, r),
                        type: 'scatter',
                        name: `ζ = ${system.dampingRatio.toFixed(3)}`,
                        line: { color: '#2c5f7c', width: 2 }
                    });
                }

                traces.push({
                    x: [fMin, fMax],
                    y: [1, 1],
                    type: 'scatter',
                    name: 'TR = 1',
                    line: { color: '#e67e22', dash: 'dash', width: 2 }
                });

                const transLayout = {
                    ...layout,
                    title: 'Transmissibility',
                    xaxis: { ...layout.xaxis, title: 'Frequency (Hz)', autorange: true },
                    yaxis: { ...layout.yaxis, title: 'Transmissibility', type: 'log', autorange: true },
                    showlegend: true,
                    legend: { x: 1, xanchor: 'right', y: 1, bgcolor: 'rgba(255,255,255,0.9)' }
                };

                Plotly.newPlot(plotDiv, traces, transLayout, config);

            } else if (currentTab === 'time') {
                const duration = parseFloat(document.getElementById('duration').value);
                const responseType = document.getElementById('timeResponseType').value;
                const excitationFreq = parseFloat(document.getElementById('excitationFreq').value);
                const amplitude = parseFloat(document.getElementById('excitationAmplitude').value);
                const initialDisp = parseFloat(document.getElementById('initialDisp').value);
                const initialVel = parseFloat(document.getElementById('initialVel').value);
                const time = linspace(0, duration, 2000); // More points for better resolution

                // Update frequency ratio display
                const freqRatio = excitationFreq / system.naturalFrequencyHz;
                document.getElementById('freqRatioDisplay').value = freqRatio.toFixed(3);

                let displacement, title, subtitle = '';
                let forceData = null;

                // Get ramp and chirp parameters
                const rampTime = parseFloat(document.getElementById('rampTime').value);
                const chirpStartFreq = parseFloat(document.getElementById('chirpStartFreq').value);
                const chirpEndFreq = parseFloat(document.getElementById('chirpEndFreq').value);

                switch (responseType) {
                    case 'impulse':
                        displacement = computeImpulseResponse(system, time, amplitude);
                        title = 'Impulse Response';
                        subtitle = `Impulse = ${amplitude} N·s`;
                        break;
                    case 'step':
                        displacement = computeStepResponse(system, time, amplitude);
                        title = 'Step Response';
                        subtitle = `F₀ = ${amplitude} N, Static deflection = ${(amplitude/system.stiffness).toExponential(3)} m`;
                        break;
                    case 'harmonic':
                        displacement = computeHarmonicResponse(system, time, excitationFreq, amplitude);
                        title = `Harmonic Response`;
                        const steadyAmp = amplitude / Math.sqrt(Math.pow(system.stiffness - system.mass * Math.pow(2*Math.PI*excitationFreq, 2), 2) + Math.pow(system.damping * 2*Math.PI*excitationFreq, 2));
                        subtitle = `f = ${excitationFreq} Hz (ω/ωn = ${freqRatio.toFixed(3)}), F₀ = ${amplitude} N, Xss = ${steadyAmp.toExponential(3)} m`;
                        break;
                    case 'ramp':
                        const rampResult = computeRampResponse(system, time, rampTime, amplitude);
                        displacement = rampResult.displacement;
                        forceData = rampResult.force;
                        title = 'Ramp Force Response';
                        subtitle = `F_final = ${amplitude} N, Ramp time = ${rampTime} s, Static deflection = ${(amplitude/system.stiffness).toExponential(3)} m`;
                        break;
                    case 'chirp':
                        const chirpResult = computeChirpResponse(system, time, chirpStartFreq, chirpEndFreq, amplitude);
                        displacement = chirpResult.displacement;
                        forceData = chirpResult.force;
                        title = 'Swept Sine (Chirp) Response';
                        subtitle = `F₀ = ${amplitude} N, Freq: ${chirpStartFreq} → ${chirpEndFreq} Hz, fn = ${system.naturalFrequencyHz.toFixed(2)} Hz`;
                        break;
                    case 'halfsine':
                        const halfsinePulseDuration = parseFloat(document.getElementById('halfsinePulseDuration').value) / 1000; // ms to s
                        const shockLevelG = amplitude; // amplitude is now in g's
                        const peakAccel = shockLevelG * 9.81; // convert to m/s²
                        const peakForce = system.mass * peakAccel; // F = ma
                        const halfsineResult = computeHalfSineResponse(system, time, halfsinePulseDuration, peakForce);
                        displacement = halfsineResult.displacement;
                        forceData = halfsineResult.force;
                        title = 'Half-Sine Pulse Response';
                        const pulsePeriod = 2 * halfsinePulseDuration;
                        const pulseFreq = 1 / pulsePeriod;
                        subtitle = `Shock = ${shockLevelG} g (${peakAccel.toFixed(1)} m/s²), Duration = ${(halfsinePulseDuration*1000).toFixed(1)} ms, Pulse freq = ${pulseFreq.toFixed(1)} Hz, fn = ${system.naturalFrequencyHz.toFixed(2)} Hz`;
                        break;
                    case 'free':
                        displacement = computeFreeVibration(system, time, initialDisp, initialVel);
                        title = 'Free Vibration';
                        subtitle = `x₀ = ${initialDisp} m, v₀ = ${initialVel} m/s`;
                        break;
                }

                const traces = [{
                    x: time,
                    y: displacement,
                    type: 'scatter',
                    name: 'Response',
                    line: { color: '#2c5f7c', width: 2 }
                }];

                // Add envelope for decaying responses
                if ((responseType === 'free' || responseType === 'impulse') && system.isUnderdamped) {
                    const maxAmp = Math.max(...displacement.map(Math.abs));
                    const envelope = time.map(t => maxAmp * Math.exp(-system.dampingRatio * system.naturalFrequency * t));
                    traces.push({
                        x: time,
                        y: envelope,
                        type: 'scatter',
                        name: 'Envelope',
                        line: { color: 'red', dash: 'dash' }
                    });
                    traces.push({
                        x: time,
                        y: envelope.map(v => -v),
                        type: 'scatter',
                        showlegend: false,
                        line: { color: 'red', dash: 'dash' }
                    });
                }

                // Add steady-state amplitude lines for harmonic response
                if (responseType === 'harmonic') {
                    const omega = 2 * Math.PI * excitationFreq;
                    const steadyAmp = amplitude / Math.sqrt(Math.pow(system.stiffness - system.mass * omega * omega, 2) + Math.pow(system.damping * omega, 2));
                    traces.push({
                        x: [time[0], time[time.length-1]],
                        y: [steadyAmp, steadyAmp],
                        type: 'scatter',
                        name: `Steady-state: ±${steadyAmp.toExponential(2)} m`,
                        line: { color: '#e67e22', dash: 'dash', width: 2 }
                    });
                    traces.push({
                        x: [time[0], time[time.length-1]],
                        y: [-steadyAmp, -steadyAmp],
                        type: 'scatter',
                        showlegend: false,
                        line: { color: '#e67e22', dash: 'dash', width: 2 }
                    });
                }

                // Add static deflection line for ramp response
                if (responseType === 'ramp') {
                    const staticDeflection = amplitude / system.stiffness;
                    traces.push({
                        x: [time[0], time[time.length-1]],
                        y: [staticDeflection, staticDeflection],
                        type: 'scatter',
                        name: `Static deflection: ${staticDeflection.toExponential(2)} m`,
                        line: { color: '#e67e22', dash: 'dash', width: 2 }
                    });
                }

                // Add max allowable displacement constraint lines
                const showMaxDisp = document.getElementById('showMaxDisp').checked;
                const maxAllowableDisp = parseFloat(document.getElementById('maxDisplacement').value);
                const maxResponseDisp = Math.max(...displacement.map(Math.abs));
                const exceedsLimit = maxResponseDisp > maxAllowableDisp;

                if (showMaxDisp) {
                    traces.push({
                        x: [time[0], time[time.length-1]],
                        y: [maxAllowableDisp, maxAllowableDisp],
                        type: 'scatter',
                        name: `Max limit: ±${maxAllowableDisp} m${exceedsLimit ? ' (EXCEEDED)' : ''}`,
                        line: { color: exceedsLimit ? '#e74c3c' : '#9b59b6', dash: 'dash', width: 2 }
                    });
                    traces.push({
                        x: [time[0], time[time.length-1]],
                        y: [-maxAllowableDisp, -maxAllowableDisp],
                        type: 'scatter',
                        showlegend: false,
                        line: { color: exceedsLimit ? '#e74c3c' : '#9b59b6', dash: 'dash', width: 2 }
                    });
                }

                // Update subtitle to include exceedance warning
                if (showMaxDisp && exceedsLimit) {
                    subtitle += ` | ⚠️ MAX EXCEEDED: ${maxResponseDisp.toExponential(2)} m > ${maxAllowableDisp} m`;
                }

                // Add force input trace for ramp, chirp, and halfsine (on secondary y-axis)
                let timeLayout;
                if (forceData && (responseType === 'ramp' || responseType === 'chirp' || responseType === 'halfsine')) {
                    // Normalize force for display
                    const maxForce = Math.max(...forceData.map(Math.abs));
                    const normalizedForce = forceData.map(f => f / maxForce);
                    const maxDisp = Math.max(...displacement.map(Math.abs));

                    traces.push({
                        x: time,
                        y: normalizedForce.map(f => f * maxDisp * 0.5),
                        type: 'scatter',
                        name: 'Force Input (scaled)',
                        line: { color: '#27ae60', width: 1, dash: 'dot' },
                        yaxis: 'y'
                    });

                    timeLayout = {
                        ...layout,
                        title: title,
                        xaxis: { ...layout.xaxis, title: 'Time (s)', autorange: true },
                        yaxis: { ...layout.yaxis, title: 'Displacement (m)', autorange: true },
                        showlegend: true,
                        legend: { x: 1, xanchor: 'right', y: 1, bgcolor: 'rgba(255,255,255,0.9)' },
                        annotations: subtitle ? [{
                            x: 0.5, y: 1.02, xref: 'paper', yref: 'paper',
                            text: subtitle, showarrow: false,
                            font: { size: 11, color: '#888' }
                        }] : []
                    };
                } else {
                    timeLayout = {
                        ...layout,
                        title: title,
                        xaxis: { ...layout.xaxis, title: 'Time (s)', autorange: true },
                        yaxis: { ...layout.yaxis, title: 'Displacement (m)', autorange: true },
                        showlegend: true,
                        legend: { x: 1, xanchor: 'right', y: 1, bgcolor: 'rgba(255,255,255,0.9)' },
                        annotations: subtitle ? [{
                            x: 0.5, y: 1.02, xref: 'paper', yref: 'paper',
                            text: subtitle, showarrow: false,
                            font: { size: 11, color: '#888' }
                        }] : []
                    };
                }

                Plotly.newPlot(plotDiv, traces, timeLayout, config);

            } else if (currentTab === 'srs') {
                const pulseType = document.getElementById('pulseType').value;
                const pulseDuration = parseFloat(document.getElementById('pulseDuration').value) / 1000; // ms to s
                const pulseAmplitude = parseFloat(document.getElementById('pulseAmplitude').value) * 9.81; // g to m/s²
                const srsFreqMin = parseFloat(document.getElementById('srsFreqMin').value);
                const srsFreqMax = parseFloat(document.getElementById('srsFreqMax').value);
                const Q = parseFloat(document.getElementById('srsDamping').value);
                const dampingRatio = 1 / (2 * Q);
                const srsType = document.getElementById('srsType').value;
                const showPulse = document.getElementById('showPulse').checked;

                // Generate frequencies (1/12 octave spacing typical for SRS)
                const frequencies = logspace(srsFreqMin, srsFreqMax, 100);

                // Time step for accurate SRS (at least 10 points per cycle at max freq)
                const dt = 1 / (srsFreqMax * 20);

                // Generate pulse
                const { t, accel } = generateShockPulse(pulseType, pulseDuration, pulseAmplitude, dt);

                // Compute SRS
                const srs = computeSRS(accel, dt, frequencies, dampingRatio);

                // Convert back to g's
                const toG = (arr) => arr.map(v => v / 9.81);

                const traces = [];

                if (srsType === 'all') {
                    traces.push({
                        x: frequencies, y: toG(srs.maxi_max),
                        type: 'scatter', name: 'Maxi-Max',
                        line: { color: '#2c5f7c', width: 2 }
                    });
                    traces.push({
                        x: frequencies, y: toG(srs.primary_pos),
                        type: 'scatter', name: 'Primary +',
                        line: { color: '#27ae60', width: 2 }
                    });
                    traces.push({
                        x: frequencies, y: toG(srs.primary_neg),
                        type: 'scatter', name: 'Primary -',
                        line: { color: '#2ecc71', width: 2 }
                    });
                    traces.push({
                        x: frequencies, y: toG(srs.residual_pos),
                        type: 'scatter', name: 'Residual +',
                        line: { color: '#c0392b', width: 2 }
                    });
                    traces.push({
                        x: frequencies, y: toG(srs.residual_neg),
                        type: 'scatter', name: 'Residual -',
                        line: { color: '#e74c3c', width: 2 }
                    });
                } else if (srsType === 'maxi_max') {
                    traces.push({
                        x: frequencies, y: toG(srs.maxi_max),
                        type: 'scatter', name: 'Maxi-Max SRS',
                        line: { color: '#2c5f7c', width: 2 }
                    });
                } else if (srsType === 'primary') {
                    traces.push({
                        x: frequencies, y: toG(srs.primary_pos),
                        type: 'scatter', name: 'Primary + SRS',
                        line: { color: '#27ae60', width: 2 }
                    });
                    traces.push({
                        x: frequencies, y: toG(srs.primary_neg),
                        type: 'scatter', name: 'Primary - SRS',
                        line: { color: '#2ecc71', width: 2 }
                    });
                } else if (srsType === 'residual') {
                    traces.push({
                        x: frequencies, y: toG(srs.residual_pos),
                        type: 'scatter', name: 'Residual + SRS',
                        line: { color: '#c0392b', width: 2 }
                    });
                    traces.push({
                        x: frequencies, y: toG(srs.residual_neg),
                        type: 'scatter', name: 'Residual - SRS',
                        line: { color: '#e74c3c', width: 2 }
                    });
                }

                // Input amplitude reference line
                traces.push({
                    x: [srsFreqMin, srsFreqMax],
                    y: [pulseAmplitude / 9.81, pulseAmplitude / 9.81],
                    type: 'scatter', name: 'Input Peak',
                    line: { color: '#e67e22', dash: 'dash', width: 2 }
                });

                let srsLayout;

                if (showPulse) {
                    // Show both pulse and SRS
                    const pulseTimeMs = t.slice(0, Math.ceil(pulseDuration * 3 / dt)).map(ti => ti * 1000);
                    const pulseAccelG = accel.slice(0, pulseTimeMs.length).map(a => a / 9.81);

                    traces.push({
                        x: pulseTimeMs,
                        y: pulseAccelG,
                        type: 'scatter',
                        name: 'Input Pulse',
                        line: { color: '#d35400', width: 2 },
                        xaxis: 'x2',
                        yaxis: 'y2'
                    });

                    srsLayout = {
                        ...layout,
                        title: `Shock Response Spectrum (Q=${Q}, ζ=${dampingRatio.toFixed(3)})`,
                        grid: { rows: 1, columns: 2, pattern: 'independent' },
                        xaxis: { ...layout.xaxis, type: 'log', title: 'Natural Frequency (Hz)', domain: [0, 0.55], autorange: true },
                        yaxis: { ...layout.yaxis, type: 'log', title: 'Peak Response (g)', autorange: true },
                        xaxis2: { ...layout.xaxis, title: 'Time (ms)', domain: [0.65, 1], autorange: true },
                        yaxis2: { ...layout.yaxis, title: 'Acceleration (g)', anchor: 'x2', autorange: true },
                        showlegend: true,
                        legend: { x: 0.55, xanchor: 'right', y: 1, bgcolor: 'rgba(255,255,255,0.9)' }
                    };
                } else {
                    srsLayout = {
                        ...layout,
                        title: `Shock Response Spectrum (Q=${Q}, ζ=${dampingRatio.toFixed(3)})`,
                        xaxis: { ...layout.xaxis, type: 'log', title: 'Natural Frequency (Hz)', autorange: true },
                        yaxis: { ...layout.yaxis, type: 'log', title: 'Peak Response (g)', autorange: true },
                        showlegend: true,
                        legend: { x: 1, xanchor: 'right', y: 1, bgcolor: 'rgba(255,255,255,0.9)' }
                    };
                }

                Plotly.newPlot(plotDiv, traces, srsLayout, config);
            }
        }

        // Event listeners
        document.getElementById('mass').addEventListener('input', updateDerivedValues);
        document.getElementById('stiffness').addEventListener('input', updateDerivedValues);
        document.getElementById('damping').addEventListener('input', updateDerivedValues);
        document.getElementById('dampingType').addEventListener('change', function() {
            const label = document.getElementById('dampingLabel');
            const input = document.getElementById('damping');
            if (this.value === 'ratio') {
                label.textContent = 'Damping Ratio (ζ)';
                input.value = '0.1';
            } else {
                label.textContent = 'Damping (N·s/m)';
                input.value = '20';
            }
            updateDerivedValues();
        });

        // Update frequency ratio display when excitation frequency changes
        document.getElementById('excitationFreq').addEventListener('input', function() {
            updateTimeOptionsVisibility();
            if (currentTab === 'time') calculate();
        });

        // Recalculate when response type changes
        document.getElementById('timeResponseType').addEventListener('change', function() {
            updateTimeOptionsVisibility();
            if (currentTab === 'time') calculate();
        });

        // Initial calculation
        updateDerivedValues();
        updateTimeOptionsVisibility();
        calculate();
    </script>
</body>
</html>
